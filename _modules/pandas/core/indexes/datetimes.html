

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.indexes.datetimes &mdash; u8timeseries  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> u8timeseries
          

          
          </a>

          
            
            
              <div class="version">
                0.0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../generated_api/u8timeseries.html">u8timeseries</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">u8timeseries</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.indexes.datetimes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.indexes.datetimes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">tzinfo</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">NaT</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">index</span> <span class="k">as</span> <span class="n">libindex</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">tslib</span> <span class="k">as</span> <span class="n">libts</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="kn">import</span> <span class="n">ccalendar</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">parsing</span><span class="p">,</span> <span class="n">timezones</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">Appender</span><span class="p">,</span> <span class="n">Substitution</span><span class="p">,</span> <span class="n">cache_readonly</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="n">_NS_DTYPE</span><span class="p">,</span> <span class="n">is_float</span><span class="p">,</span> <span class="n">is_integer</span><span class="p">,</span> <span class="n">is_scalar</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="n">DatetimeTZDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">is_valid_nat_for_dtype</span><span class="p">,</span> <span class="n">isna</span>

<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="kn">import</span> <span class="n">delegate_names</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.datetimes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
    <span class="n">tz_to_dtype</span><span class="p">,</span>
    <span class="n">validate_tz_from_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="kn">import</span> <span class="n">_shared_docs</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.base</span> <span class="kn">import</span> <span class="n">Index</span><span class="p">,</span> <span class="n">maybe_extract_name</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimelike</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimelikeDelegateMixin</span><span class="p">,</span>
    <span class="n">DatetimeTimedeltaMixin</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.extension</span> <span class="kn">import</span> <span class="n">inherit_names</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="kn">import</span> <span class="n">get_op_result_name</span>
<span class="kn">import</span> <span class="nn">pandas.core.tools.datetimes</span> <span class="k">as</span> <span class="nn">tools</span>

<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">Resolution</span><span class="p">,</span> <span class="n">to_offset</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.offsets</span> <span class="kn">import</span> <span class="n">Nano</span><span class="p">,</span> <span class="n">prefix_mapping</span>


<span class="k">def</span> <span class="nf">_new_DatetimeIndex</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is called upon unpickling, rather than the default which doesn&#39;t</span>
<span class="sd">    have arguments and breaks __new__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;data&quot;</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
        <span class="c1"># Avoid need to verify integrity by calling simple_new directly</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="c1"># TODO: If we knew what was going in to **d, we might be able to</span>
            <span class="c1">#  go through _simple_new instead</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">DatetimeDelegateMixin</span><span class="p">(</span><span class="n">DatetimelikeDelegateMixin</span><span class="p">):</span>
    <span class="c1"># Most attrs are dispatched via datetimelike_{ops,methods}</span>
    <span class="c1"># Some are &quot;raw&quot; methods, the result is not not re-boxed in an Index</span>
    <span class="c1"># We also have a few &quot;extra&quot; attrs, which may or may not be raw,</span>
    <span class="c1"># which we we dont&#39; want to expose in the .dt accessor.</span>
    <span class="n">_extra_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;to_period&quot;</span><span class="p">,</span> <span class="s2">&quot;to_perioddelta&quot;</span><span class="p">,</span> <span class="s2">&quot;to_julian_date&quot;</span><span class="p">,</span> <span class="s2">&quot;strftime&quot;</span><span class="p">]</span>
    <span class="n">_extra_raw_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;to_pydatetime&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_local_timestamps&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_has_same_tz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_format_native_types&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__iter__&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">_extra_raw_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_box_func&quot;</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="s2">&quot;tzinfo&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
    <span class="n">_delegated_properties</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_datetimelike_ops</span> <span class="o">+</span> <span class="n">_extra_raw_properties</span>
    <span class="n">_delegated_methods</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_datetimelike_methods</span> <span class="o">+</span> <span class="n">_extra_methods</span> <span class="o">+</span> <span class="n">_extra_raw_methods</span>
    <span class="p">)</span>
    <span class="n">_raw_properties</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;timetz&quot;</span><span class="p">}</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_bool_ops</span><span class="p">)</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">_extra_raw_properties</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">_raw_methods</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_extra_raw_methods</span><span class="p">)</span>


<span class="nd">@inherit_names</span><span class="p">([</span><span class="s2">&quot;_timezone&quot;</span><span class="p">,</span> <span class="s2">&quot;is_normalized&quot;</span><span class="p">,</span> <span class="s2">&quot;_resolution&quot;</span><span class="p">],</span> <span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nd">@inherit_names</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="s2">&quot;_bool_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_object_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_field_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_datetimelike_ops&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_datetimelike_methods&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="nd">@delegate_names</span><span class="p">(</span>
    <span class="n">DatetimeArray</span><span class="p">,</span> <span class="n">DatetimeDelegateMixin</span><span class="o">.</span><span class="n">_delegated_properties</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s2">&quot;property&quot;</span>
<span class="p">)</span>
<span class="nd">@delegate_names</span><span class="p">(</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
    <span class="n">DatetimeDelegateMixin</span><span class="o">.</span><span class="n">_delegated_methods</span><span class="p">,</span>
    <span class="n">typ</span><span class="o">=</span><span class="s2">&quot;method&quot;</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">DatetimeIndex</span><span class="p">(</span><span class="n">DatetimeTimedeltaMixin</span><span class="p">,</span> <span class="n">DatetimeDelegateMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Immutable ndarray of datetime64 data, represented internally as int64, and</span>
<span class="sd">    which can be boxed to Timestamp objects that are subclasses of datetime and</span>
<span class="sd">    carry metadata such as frequency information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like (1-dimensional), optional</span>
<span class="sd">        Optional datetime-like data to construct index with.</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Make a copy of input ndarray.</span>
<span class="sd">    freq : str or pandas offset object, optional</span>
<span class="sd">        One of pandas date offset strings or corresponding objects. The string</span>
<span class="sd">        &#39;infer&#39; can be passed in order to set the frequency of the index as the</span>
<span class="sd">        inferred frequency upon creation.</span>
<span class="sd">    tz : pytz.timezone or dateutil.tz.tzfile</span>
<span class="sd">    ambiguous : &#39;infer&#39;, bool-ndarray, &#39;NaT&#39;, default &#39;raise&#39;</span>
<span class="sd">        When clocks moved backward due to DST, ambiguous times may arise.</span>
<span class="sd">        For example in Central European Time (UTC+01), when going from 03:00</span>
<span class="sd">        DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC</span>
<span class="sd">        and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter</span>
<span class="sd">        dictates how ambiguous times should be handled.</span>

<span class="sd">        - &#39;infer&#39; will attempt to infer fall dst-transition hours based on</span>
<span class="sd">          order</span>
<span class="sd">        - bool-ndarray where True signifies a DST time, False signifies a</span>
<span class="sd">          non-DST time (note that this flag is only applicable for ambiguous</span>
<span class="sd">          times)</span>
<span class="sd">        - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">        - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous times.</span>
<span class="sd">    name : object</span>
<span class="sd">        Name to be stored in the index.</span>
<span class="sd">    dayfirst : bool, default False</span>
<span class="sd">        If True, parse dates in `data` with the day first order.</span>
<span class="sd">    yearfirst : bool, default False</span>
<span class="sd">        If True parse dates in `data` with the year first order.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    year</span>
<span class="sd">    month</span>
<span class="sd">    day</span>
<span class="sd">    hour</span>
<span class="sd">    minute</span>
<span class="sd">    second</span>
<span class="sd">    microsecond</span>
<span class="sd">    nanosecond</span>
<span class="sd">    date</span>
<span class="sd">    time</span>
<span class="sd">    timetz</span>
<span class="sd">    dayofyear</span>
<span class="sd">    weekofyear</span>
<span class="sd">    week</span>
<span class="sd">    dayofweek</span>
<span class="sd">    weekday</span>
<span class="sd">    quarter</span>
<span class="sd">    tz</span>
<span class="sd">    freq</span>
<span class="sd">    freqstr</span>
<span class="sd">    is_month_start</span>
<span class="sd">    is_month_end</span>
<span class="sd">    is_quarter_start</span>
<span class="sd">    is_quarter_end</span>
<span class="sd">    is_year_start</span>
<span class="sd">    is_year_end</span>
<span class="sd">    is_leap_year</span>
<span class="sd">    inferred_freq</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    normalize</span>
<span class="sd">    strftime</span>
<span class="sd">    snap</span>
<span class="sd">    tz_convert</span>
<span class="sd">    tz_localize</span>
<span class="sd">    round</span>
<span class="sd">    floor</span>
<span class="sd">    ceil</span>
<span class="sd">    to_period</span>
<span class="sd">    to_perioddelta</span>
<span class="sd">    to_pydatetime</span>
<span class="sd">    to_series</span>
<span class="sd">    to_frame</span>
<span class="sd">    month_name</span>
<span class="sd">    day_name</span>
<span class="sd">    mean</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Index : The base pandas Index type.</span>
<span class="sd">    TimedeltaIndex : Index of timedelta64 data.</span>
<span class="sd">    PeriodIndex : Index of Period data.</span>
<span class="sd">    to_datetime : Convert argument to datetime.</span>
<span class="sd">    date_range : Create a fixed-frequency DatetimeIndex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To learn more about the frequency strings, please see `this link</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_typ</span> <span class="o">=</span> <span class="s2">&quot;datetimeindex&quot;</span>

    <span class="n">_engine_type</span> <span class="o">=</span> <span class="n">libindex</span><span class="o">.</span><span class="n">DatetimeEngine</span>
    <span class="n">_supports_partial_string_indexing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_comparables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;freqstr&quot;</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">]</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;tz&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">]</span>

    <span class="n">_is_numeric_dtype</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_infer_as_myclass</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tzinfo</span><span class="p">]</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ambiguous</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
        <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">yearfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() must be called with a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;collection of some kind, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> was passed&quot;</span>
            <span class="p">)</span>

        <span class="c1"># - Cases checked above all return/raise before reaching here - #</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">maybe_extract_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

        <span class="n">dtarr</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span>
            <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">,</span>
            <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">subarr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dtarr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">dtarr</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">dtarr</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subarr</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_simple_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We require the we have a dtype compat for the values</span>
<span class="sd">        if we are passed a non-dtype compat, then coerce using the constructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">DatetimeArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tz</span><span class="p">:</span>
                <span class="n">tz</span> <span class="o">=</span> <span class="n">validate_tz_from_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">DatetimeTZDtype</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">_NS_DTYPE</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">tz</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">freq</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_data</span>

        <span class="c1"># DatetimeArray._simple_new will accept either i8 or M8[ns] dtypes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_data</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">tz_to_dtype</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">dtarr</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtarr</span><span class="p">,</span> <span class="n">DatetimeArray</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">dtarr</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_no_setting_name</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># For groupby perf. See note in indexes/base about _index_data</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_index_data</span> <span class="o">=</span> <span class="n">dtarr</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_reset_identity</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_is_dates_only</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean if we are only dates (and don&#39;t have a timezone)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">_is_dates_only</span>

        <span class="k">return</span> <span class="n">_is_dates_only</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># we use a special reduce here because we need</span>
        <span class="c1"># to simply set the .tz (and not reinterpret it)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">_new_DatetimeIndex</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">d</span><span class="p">),</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_convert_for_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert value to be insertable to ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_same_tz</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">asm8</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passed item and index have different timezone&quot;</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">_mpl_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># how to represent ourselves to matplotlib</span>
        <span class="k">return</span> <span class="n">libts</span><span class="o">.</span><span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_formatter_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="kn">import</span> <span class="n">_get_format_datetime64</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">_get_format_datetime64</span><span class="p">(</span><span class="n">is_dates_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_dates_only</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

    <span class="c1"># --------------------------------------------------------------------</span>
    <span class="c1"># Set Operation Methods</span>

    <span class="k">def</span> <span class="nf">union_many</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bit of a hack to accelerate unioning a collection of indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_maybe_utc_convert</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">this</span><span class="o">.</span><span class="n">_can_fast_union</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_fast_union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">dtype</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
                    <span class="c1"># TODO: we shouldn&#39;t be setting attributes like this;</span>
                    <span class="c1">#  in all the tests this equality already holds</span>
                    <span class="n">this</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">_wrap_setop_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_get_time_micros</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">timezones</span><span class="o">.</span><span class="n">is_utc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_local_timestamps</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fields</span><span class="o">.</span><span class="n">get_time_micros</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_tz</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Series with both index and values equal to the index keys</span>
<span class="sd">        useful with map for returning an indexer based on an index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep_tz : optional, defaults True</span>
<span class="sd">            Return the data keeping the timezone.</span>

<span class="sd">            If keep_tz is True:</span>

<span class="sd">              If the timezone is not set, the resulting</span>
<span class="sd">              Series will have a datetime64[ns] dtype.</span>

<span class="sd">              Otherwise the Series will have an datetime64[ns, tz] dtype; the</span>
<span class="sd">              tz will be preserved.</span>

<span class="sd">            If keep_tz is False:</span>

<span class="sd">              Series will have a datetime64[ns] dtype. TZ aware</span>
<span class="sd">              objects will have the tz removed.</span>

<span class="sd">            .. versionchanged:: 1.0.0</span>
<span class="sd">                The default value is now True.  In a future version,</span>
<span class="sd">                this keyword will be removed entirely.  Stop passing the</span>
<span class="sd">                argument to obtain the future behavior and silence the warning.</span>

<span class="sd">        index : Index, optional</span>
<span class="sd">            Index of resulting Series. If None, defaults to original index.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name of resulting Series. If None, defaults to name of original</span>
<span class="sd">            index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">keep_tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keep_tz</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The &#39;keep_tz&#39; keyword in DatetimeIndex.to_series &quot;</span>
                    <span class="s2">&quot;is deprecated and will be removed in a future version.  &quot;</span>
                    <span class="s2">&quot;You can stop passing &#39;keep_tz&#39; to silence this warning.&quot;</span><span class="p">,</span>
                    <span class="ne">FutureWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Specifying &#39;keep_tz=False&#39; is deprecated and this &quot;</span>
                    <span class="s2">&quot;option will be removed in a future release. If &quot;</span>
                    <span class="s2">&quot;you want to remove the timezone information, you &quot;</span>
                    <span class="s2">&quot;can do &#39;idx.tz_convert(None)&#39; before calling &quot;</span>
                    <span class="s2">&quot;&#39;to_series&#39;.&quot;</span><span class="p">,</span>
                    <span class="ne">FutureWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep_tz</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">keep_tz</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># preserve the tz &amp; copy</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">snap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Snap time stamps to nearest occurring frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DatetimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Superdumb, punting on any optimizing</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">snapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_NS_DTYPE</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">freq</span><span class="o">.</span><span class="n">is_on_offset</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">t0</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">rollforward</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">s</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">t0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">t1</span>
            <span class="n">snapped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c1"># we know it conforms; skip check</span>
        <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">snapped</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parsed_string_to_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reso</span><span class="p">,</span> <span class="n">parsed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate datetime bounds for parsed time string and its resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reso : Resolution</span>
<span class="sd">            Resolution provided by parsed string.</span>
<span class="sd">        parsed : datetime</span>
<span class="sd">            Datetime from parsed string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lower, upper: pd.Timestamp</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_resos</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;year&quot;</span><span class="p">,</span>
            <span class="s2">&quot;month&quot;</span><span class="p">,</span>
            <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;day&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hour&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
            <span class="s2">&quot;second&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minute&quot;</span><span class="p">,</span>
            <span class="s2">&quot;second&quot;</span><span class="p">,</span>
            <span class="s2">&quot;microsecond&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">reso</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_resos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>
        <span class="k">if</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;month&quot;</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ccalendar</span><span class="o">.</span><span class="n">get_days_in_month</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;quarter&quot;</span><span class="p">:</span>
            <span class="n">qe</span> <span class="o">=</span> <span class="p">(((</span><span class="n">parsed</span><span class="o">.</span><span class="n">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># two months ahead</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ccalendar</span><span class="o">.</span><span class="n">get_days_in_month</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">qe</span><span class="p">)</span>  <span class="c1"># at end of month</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">qe</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;day&quot;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Nano</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;hour&quot;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Nano</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;minute&quot;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">parsed</span><span class="o">.</span><span class="n">minute</span>
            <span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Nano</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;second&quot;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">day</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Nano</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;microsecond&quot;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">month</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">day</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
                <span class="n">parsed</span><span class="o">.</span><span class="n">microsecond</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">microseconds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Nano</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># GH 24076</span>
        <span class="c1"># If an incoming date string contained a UTC offset, need to localize</span>
        <span class="c1"># the parsed date to this offset first before aligning with the index&#39;s</span>
        <span class="c1"># timezone</span>
        <span class="k">if</span> <span class="n">parsed</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The index must be timezone aware when indexing &quot;</span>
                    <span class="s2">&quot;with a date string with a UTC offset&quot;</span>
                <span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">)</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">)</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>

    <span class="k">def</span> <span class="nf">_partial_date_slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reso</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parsed</span><span class="p">,</span> <span class="n">use_lhs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_rhs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reso : str</span>
<span class="sd">        use_lhs : bool, default True</span>
<span class="sd">        use_rhs : bool, default True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_monotonic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">is_monotonic</span>
            <span class="ow">and</span> <span class="n">reso</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">,</span> <span class="s2">&quot;hour&quot;</span><span class="p">,</span> <span class="s2">&quot;minute&quot;</span><span class="p">,</span> <span class="s2">&quot;second&quot;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolution</span> <span class="o">&gt;=</span> <span class="n">Resolution</span><span class="o">.</span><span class="n">get_reso</span><span class="p">(</span><span class="n">reso</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># These resolution/monotonicity validations came from GH3931,</span>
            <span class="c1"># GH3452 and GH2369.</span>

            <span class="c1"># See also GH14826</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>

        <span class="k">if</span> <span class="n">reso</span> <span class="o">==</span> <span class="s2">&quot;microsecond&quot;</span><span class="p">:</span>
            <span class="c1"># _partial_date_slice doesn&#39;t allow microsecond resolution, but</span>
            <span class="c1"># _parsed_string_to_bounds allows it.</span>
            <span class="k">raise</span> <span class="ne">KeyError</span>

        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsed_string_to_bounds</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">parsed</span><span class="p">)</span>
        <span class="n">stamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span>

        <span class="k">if</span> <span class="n">is_monotonic</span><span class="p">:</span>

            <span class="c1"># we are out of range</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stamps</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">use_lhs</span> <span class="ow">and</span> <span class="n">t1</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">stamps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">t2</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">stamps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="ow">or</span> <span class="p">((</span><span class="n">use_rhs</span> <span class="ow">and</span> <span class="n">t1</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">stamps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">t2</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">stamps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span>

            <span class="c1"># a monotonic (sorted) series can be sliced</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">stamps</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_lhs</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">stamps</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_rhs</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">lhs_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">stamps</span> <span class="o">&gt;=</span> <span class="n">t1</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_lhs</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="n">rhs_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">stamps</span> <span class="o">&lt;=</span> <span class="n">t2</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_rhs</span> <span class="k">else</span> <span class="kc">True</span>

        <span class="c1"># try to find a the dates</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lhs_mask</span> <span class="o">&amp;</span> <span class="n">rhs_mask</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_maybe_promote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s2">&quot;date&quot;</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast lookup of value from 1-dimensional ndarray. Only use this if you</span>
<span class="sd">        know what you&#39;re doing</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">datetime</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value_maybe_box</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_string_slice</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">series</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="k">pass</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value_maybe_box</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value_maybe_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># needed to localize naive datetimes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">series</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integer location for requested label</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loc : int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># try converting tolerance now, so errors don&#39;t get swallowed by</span>
            <span class="c1"># the try/except clauses below</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_tolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="c1"># needed to localize naive datetimes</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">):</span>
            <span class="c1"># GH#20464</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot index </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot yet lookup inexact labels when key is a time object&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_string_slice</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
                <span class="k">pass</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">stamp</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stamp</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">stamp</span> <span class="o">=</span> <span class="n">stamp</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stamp</span> <span class="o">=</span> <span class="n">stamp</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stamp</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># list-like tolerance size must match target index size</span>
                <span class="k">if</span> <span class="s2">&quot;list-like&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_slice_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If label is a string, cast it to datetime according to resolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}</span>
<span class="sd">        kind : {&#39;ix&#39;, &#39;loc&#39;, &#39;getitem&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        label : object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Value of `side` parameter should be validated in caller.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ix&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;getitem&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_float</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s2">&quot;slice&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;freqstr&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;inferred_freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">parsed</span><span class="p">,</span> <span class="n">reso</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">parse_time_string</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsed_string_to_bounds</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">parsed</span><span class="p">)</span>
            <span class="c1"># lower, upper form the half-open interval:</span>
            <span class="c1">#   [parsed, parsed + 1 freq)</span>
            <span class="c1"># because label may be passed to searchsorted</span>
            <span class="c1"># the bounds need swapped if index is reverse sorted and has a</span>
            <span class="c1"># length &gt; 1 (is_monotonic_decreasing gives True for empty</span>
            <span class="c1"># and length 1 index)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_strictly_monotonic_decreasing</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">upper</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="n">lower</span>
            <span class="k">return</span> <span class="n">lower</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="n">upper</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_get_string_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_lhs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_rhs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;freqstr&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;inferred_freq&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">parsed</span><span class="p">,</span> <span class="n">reso</span> <span class="o">=</span> <span class="n">parsing</span><span class="o">.</span><span class="n">parse_time_string</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_date_slice</span><span class="p">(</span><span class="n">reso</span><span class="p">,</span> <span class="n">parsed</span><span class="p">,</span> <span class="n">use_lhs</span><span class="o">=</span><span class="n">use_lhs</span><span class="p">,</span> <span class="n">use_rhs</span><span class="o">=</span><span class="n">use_rhs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return indexer for specified label slice.</span>
<span class="sd">        Index.slice_indexer, customized to handle time slicing.</span>

<span class="sd">        In addition to functionality provided by Index.slice_indexer, does the</span>
<span class="sd">        following:</span>

<span class="sd">        - if both `start` and `end` are instances of `datetime.time`, it</span>
<span class="sd">          invokes `indexer_between_time`</span>
<span class="sd">        - if `start` and `end` are both either string or None perform</span>
<span class="sd">          value-based selection in non-monotonic cases.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For historical reasons DatetimeIndex supports slices between two</span>
        <span class="c1"># instances of datetime.time as if it were applying a slice mask to</span>
        <span class="c1"># an array of (self.hour, self.minute, self.seconds, self.microsecond).</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have step size of 1 with time slices&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexer_between_time</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot mix time and non-time slice keys&quot;</span><span class="p">)</span>

        <span class="c1"># Pandas supports slicing with dates, treated as datetimes at midnight.</span>
        <span class="c1"># https://github.com/pandas-dev/pandas/issues/31501</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Index</span><span class="o">.</span><span class="n">slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># For historical reasons DatetimeIndex by default supports</span>
            <span class="c1"># value-based partial (aka string) slices on non-monotonic arrays,</span>
            <span class="c1"># let&#39;s try that.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start_casted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_slice_bound</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">start_casted</span> <span class="o">&lt;=</span> <span class="bp">self</span>

                <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">end_casted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_slice_bound</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">end_casted</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>

                <span class="n">indexer</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][::</span><span class="n">step</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">indexer</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="c1"># --------------------------------------------------------------------</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;DatetimeIndex&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;searchsorted&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="o">.</span><span class="n">_is_recognized_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;searchsorted requires compatible dtype or scalar, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_check_compatible_with</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_recognized_scalars</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_check_compatible_with</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_scalar_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DatetimeArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;searchsorted requires compatible dtype or scalar, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_type_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">typ</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s2">&quot;datetime&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inferred_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># b/c datetime is represented as microseconds since the epoch, make</span>
        <span class="c1"># sure we can&#39;t have ambiguous indexing</span>
        <span class="k">return</span> <span class="s2">&quot;datetime64&quot;</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index inserting new item at location</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">        item : object</span>
<span class="sd">            if not either a Python datetime or a numpy integer-like, returned</span>
<span class="sd">            Index dtype will be object rather than datetime.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_recognized_scalars</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_scalar_type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_valid_nat_for_dtype</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># GH 18295</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="c1"># i.e. timedeltat64(&quot;NaT&quot;)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot insert </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with incompatible label&quot;</span>
            <span class="p">)</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_scalar_type</span><span class="p">)</span> <span class="ow">or</span> <span class="n">item</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_check_compatible_with</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">setitem</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># check freq can be preserved on edge cases</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">loc</span> <span class="o">==</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">asm8</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_i8s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">asi8</span><span class="p">,</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)],</span> <span class="bp">self</span><span class="p">[</span><span class="n">loc</span><span class="p">:]</span><span class="o">.</span><span class="n">asi8</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">new_i8s</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>

            <span class="c1"># fall back to object index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot insert </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with incompatible label&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">indexer_at_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index locations of index values at particular time of day</span>
<span class="sd">        (e.g. 9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : datetime.time or str</span>
<span class="sd">            datetime.time or string in appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;,</span>
<span class="sd">            &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;, &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;,</span>
<span class="sd">            &quot;%I%M%S%p&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_at_time : array of integers</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        indexer_between_time, DataFrame.at_time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">asof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;asof&#39; argument is not supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">dateutil.parser</span> <span class="kn">import</span> <span class="n">parse</span>

            <span class="n">time</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index must be timezone aware.&quot;</span><span class="p">)</span>
            <span class="n">time_micros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">)</span><span class="o">.</span><span class="n">_get_time_micros</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_micros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_micros</span><span class="p">()</span>
        <span class="n">micros</span> <span class="o">=</span> <span class="n">_time_to_micros</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">micros</span> <span class="o">==</span> <span class="n">time_micros</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">indexer_between_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_end</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index locations of values between particular times of day</span>
<span class="sd">        (e.g., 9:00-9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time, end_time : datetime.time, str</span>
<span class="sd">            datetime.time or string in appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;,</span>
<span class="sd">            &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;, &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;,</span>
<span class="sd">            &quot;%I%M%S%p&quot;).</span>
<span class="sd">        include_start : bool, default True</span>
<span class="sd">        include_end : bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_between_time : array of integers</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        indexer_at_time, DataFrame.between_time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">to_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">to_time</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
        <span class="n">time_micros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_micros</span><span class="p">()</span>
        <span class="n">start_micros</span> <span class="o">=</span> <span class="n">_time_to_micros</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
        <span class="n">end_micros</span> <span class="o">=</span> <span class="n">_time_to_micros</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_start</span> <span class="ow">and</span> <span class="n">include_end</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
        <span class="k">elif</span> <span class="n">include_start</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
            <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>
        <span class="k">elif</span> <span class="n">include_end</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>
            <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lop</span> <span class="o">=</span> <span class="n">rop</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span>

        <span class="k">if</span> <span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="n">join_op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">join_op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">join_op</span><span class="p">(</span><span class="n">lop</span><span class="p">(</span><span class="n">start_micros</span><span class="p">,</span> <span class="n">time_micros</span><span class="p">),</span> <span class="n">rop</span><span class="p">(</span><span class="n">time_micros</span><span class="p">,</span> <span class="n">end_micros</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>


<span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_add_numeric_methods_disabled</span><span class="p">()</span>
<span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_add_logical_methods_disabled</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">date_range</span><span class="p">(</span>
    <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a fixed frequency DatetimeIndex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : str or datetime-like, optional</span>
<span class="sd">        Left bound for generating dates.</span>
<span class="sd">    end : str or datetime-like, optional</span>
<span class="sd">        Right bound for generating dates.</span>
<span class="sd">    periods : int, optional</span>
<span class="sd">        Number of periods to generate.</span>
<span class="sd">    freq : str or DateOffset, default &#39;D&#39;</span>
<span class="sd">        Frequency strings can have multiples, e.g. &#39;5H&#39;. See</span>
<span class="sd">        :ref:`here &lt;timeseries.offset_aliases&gt;` for a list of</span>
<span class="sd">        frequency aliases.</span>
<span class="sd">    tz : str or tzinfo, optional</span>
<span class="sd">        Time zone name for returning localized DatetimeIndex, for example</span>
<span class="sd">        &#39;Asia/Hong_Kong&#39;. By default, the resulting DatetimeIndex is</span>
<span class="sd">        timezone-naive.</span>
<span class="sd">    normalize : bool, default False</span>
<span class="sd">        Normalize start/end dates to midnight before generating date range.</span>
<span class="sd">    name : str, default None</span>
<span class="sd">        Name of the resulting DatetimeIndex.</span>
<span class="sd">    closed : {None, &#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">        Make the interval closed with respect to the given frequency to</span>
<span class="sd">        the &#39;left&#39;, &#39;right&#39;, or both sides (None, the default).</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For compatibility. Has no effect on the result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rng : DatetimeIndex</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DatetimeIndex : An immutable container for datetimes.</span>
<span class="sd">    timedelta_range : Return a fixed frequency TimedeltaIndex.</span>
<span class="sd">    period_range : Return a fixed frequency PeriodIndex.</span>
<span class="sd">    interval_range : Return a fixed frequency IntervalIndex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,</span>
<span class="sd">    exactly three must be specified. If ``freq`` is omitted, the resulting</span>
<span class="sd">    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between</span>
<span class="sd">    ``start`` and ``end`` (closed on both sides).</span>

<span class="sd">    To learn more about the frequency strings, please see `this link</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Specifying the values**</span>

<span class="sd">    The next four examples generate the same `DatetimeIndex`, but vary</span>
<span class="sd">    the combination of `start`, `end` and `periods`.</span>

<span class="sd">    Specify `start` and `end`, with the default daily frequency.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,</span>
<span class="sd">                   &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Specify `start` and `periods`, the number of periods (days).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=8)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,</span>
<span class="sd">                   &#39;2018-01-05&#39;, &#39;2018-01-06&#39;, &#39;2018-01-07&#39;, &#39;2018-01-08&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Specify `end` and `periods`, the number of periods (days).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(end=&#39;1/1/2018&#39;, periods=8)</span>
<span class="sd">    DatetimeIndex([&#39;2017-12-25&#39;, &#39;2017-12-26&#39;, &#39;2017-12-27&#39;, &#39;2017-12-28&#39;,</span>
<span class="sd">                   &#39;2017-12-29&#39;, &#39;2017-12-30&#39;, &#39;2017-12-31&#39;, &#39;2018-01-01&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Specify `start`, `end`, and `periods`; the frequency is generated</span>
<span class="sd">    automatically (linearly spaced).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-04-27&#39;, periods=3)</span>
<span class="sd">    DatetimeIndex([&#39;2018-04-24 00:00:00&#39;, &#39;2018-04-25 12:00:00&#39;,</span>
<span class="sd">                   &#39;2018-04-27 00:00:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">    **Other Parameters**</span>

<span class="sd">    Changed the `freq` (frequency) to ``&#39;M&#39;`` (month end frequency).</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;M&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-02-28&#39;, &#39;2018-03-31&#39;, &#39;2018-04-30&#39;,</span>
<span class="sd">                   &#39;2018-05-31&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</span>

<span class="sd">    Multiples are allowed</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;3M&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,</span>
<span class="sd">                   &#39;2019-01-31&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)</span>

<span class="sd">    `freq` can also be specified as an Offset object.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=pd.offsets.MonthEnd(3))</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-31&#39;, &#39;2018-04-30&#39;, &#39;2018-07-31&#39;, &#39;2018-10-31&#39;,</span>
<span class="sd">                   &#39;2019-01-31&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;3M&#39;)</span>

<span class="sd">    Specify `tz` to set the timezone.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01 00:00:00+09:00&#39;, &#39;2018-01-02 00:00:00+09:00&#39;,</span>
<span class="sd">                   &#39;2018-01-03 00:00:00+09:00&#39;, &#39;2018-01-04 00:00:00+09:00&#39;,</span>
<span class="sd">                   &#39;2018-01-05 00:00:00+09:00&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns, Asia/Tokyo]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    `closed` controls whether to include `start` and `end` that are on the</span>
<span class="sd">    boundary. The default includes boundary points on either end.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2017-01-01&#39;, end=&#39;2017-01-04&#39;, closed=None)</span>
<span class="sd">    DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Use ``closed=&#39;left&#39;`` to exclude `end` if it falls on the boundary.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2017-01-01&#39;, end=&#39;2017-01-04&#39;, closed=&#39;left&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>

<span class="sd">    Use ``closed=&#39;right&#39;`` to exclude `start` if it falls on the boundary.</span>

<span class="sd">    &gt;&gt;&gt; pd.date_range(start=&#39;2017-01-01&#39;, end=&#39;2017-01-04&#39;, closed=&#39;right&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;],</span>
<span class="sd">                  dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">com</span><span class="o">.</span><span class="n">any_none</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span>

    <span class="n">dtarr</span> <span class="o">=</span> <span class="n">DatetimeArray</span><span class="o">.</span><span class="n">_generate_range</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">dtarr</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">dtarr</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">dtarr</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bdate_range</span><span class="p">(</span>
    <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span>
    <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weekmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">holidays</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DatetimeIndex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a fixed frequency DatetimeIndex, with business day as the default</span>
<span class="sd">    frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : str or datetime-like, default None</span>
<span class="sd">        Left bound for generating dates.</span>
<span class="sd">    end : str or datetime-like, default None</span>
<span class="sd">        Right bound for generating dates.</span>
<span class="sd">    periods : int, default None</span>
<span class="sd">        Number of periods to generate.</span>
<span class="sd">    freq : str or DateOffset, default &#39;B&#39; (business daily)</span>
<span class="sd">        Frequency strings can have multiples, e.g. &#39;5H&#39;.</span>
<span class="sd">    tz : str or None</span>
<span class="sd">        Time zone name for returning localized DatetimeIndex, for example</span>
<span class="sd">        Asia/Beijing.</span>
<span class="sd">    normalize : bool, default False</span>
<span class="sd">        Normalize start/end dates to midnight before generating date range.</span>
<span class="sd">    name : str, default None</span>
<span class="sd">        Name of the resulting DatetimeIndex.</span>
<span class="sd">    weekmask : str or None, default None</span>
<span class="sd">        Weekmask of valid business days, passed to ``numpy.busdaycalendar``,</span>
<span class="sd">        only used when custom frequency strings are passed.  The default</span>
<span class="sd">        value None is equivalent to &#39;Mon Tue Wed Thu Fri&#39;.</span>

<span class="sd">        .. versionadded:: 0.21.0</span>

<span class="sd">    holidays : list-like or None, default None</span>
<span class="sd">        Dates to exclude from the set of valid business days, passed to</span>
<span class="sd">        ``numpy.busdaycalendar``, only used when custom frequency strings</span>
<span class="sd">        are passed.</span>

<span class="sd">        .. versionadded:: 0.21.0</span>

<span class="sd">    closed : str, default None</span>
<span class="sd">        Make the interval closed with respect to the given frequency to</span>
<span class="sd">        the &#39;left&#39;, &#39;right&#39;, or both sides (None).</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For compatibility. Has no effect on the result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DatetimeIndex</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``,</span>
<span class="sd">    exactly three must be specified.  Specifying ``freq`` is a requirement</span>
<span class="sd">    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not</span>
<span class="sd">    desired.</span>

<span class="sd">    To learn more about the frequency strings, please see `this link</span>
<span class="sd">    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Note how the two weekend days are skipped in the result.</span>

<span class="sd">    &gt;&gt;&gt; pd.bdate_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;)</span>
<span class="sd">    DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-02&#39;, &#39;2018-01-03&#39;, &#39;2018-01-04&#39;,</span>
<span class="sd">               &#39;2018-01-05&#39;, &#39;2018-01-08&#39;],</span>
<span class="sd">              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;freq must be specified for bdate_range; use date_range instead&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">freq</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">weekmask</span> <span class="o">=</span> <span class="n">weekmask</span> <span class="ow">or</span> <span class="s2">&quot;Mon Tue Wed Thu Fri&quot;</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">prefix_mapping</span><span class="p">[</span><span class="n">freq</span><span class="p">](</span><span class="n">holidays</span><span class="o">=</span><span class="n">holidays</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="n">weekmask</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;invalid custom frequency string: </span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">holidays</span> <span class="ow">or</span> <span class="n">weekmask</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;a custom frequency string is required when holidays or &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;weekmask are passed, got frequency </span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">date_range</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span>
        <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
        <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_time_to_micros</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="n">seconds</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">minute</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">second</span>
    <span class="k">return</span> <span class="mi">1000000</span> <span class="o">*</span> <span class="n">seconds</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">microsecond</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, unit8

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>